/*
 * Arduino YM2149 MIDI Synth v0.5
 * 
 * Original code developed by yukimizake.
 * Video demonstration: Soon.
 * Schematics: Soon.
 * Based on re-factored code by Dansfing / dansfing.uk
 * Updated PCB design and modifications for 2024 by crunchypotato for HobbyChop.
 * OLED display not initially supported in this version but the pins are available on the PCB headers.
 * Replaced 2 samples for Channel 10 with smaller samples.
 * Added comments to playNote code.
 * Remapped velocity 1-127 to 64-127 and implemented velocity examples in MIDI CH. 1 and 4. 
 * Reserved for future progress.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <Arduino.h>
#include <U8x8lib.h>

//U8X8_SSD1306_128X64_NONAME_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE);         
U8X8_SH1106_128X64_NONAME_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE);

//Port settings
const int ad0 = 8;
const int ad1 = 9;
const int ad2 = 2;
const int ad3 = 3;
const int ad4 = 4;
const int ad5 = 5;
const int ad6 = 6;
const int ad7 = 7;
const int pinBC1 = 10;   
const int pinBDIR = 11;
//BC2 to +5V
const int pinYMReset = 12;

// Buttons on Analogue Pin A1
#define buttonPin A1       // analog input pin to use as a digital input
  
//voicing
byte noteA = 0;
byte noteB = 0;
byte noteC = 0;
int periodA = 0;
int periodB = 0;
int periodC = 0;

//MIDI MUTES
int mm0=0;
int mm1=0;
int mm2=0;
int mm3=0;
int mm4=0;
int mm5=0;
int mm6=0;
int mm7=0;

//envelope
byte AmaxVolume = 0;
byte BmaxVolume = 0;
byte CmaxVolume = 0;

//unison detune
int detuneValue = 1;

//arpeggio settings
byte arpeggio[] = {0,7,12};
byte arpeggioLength = 3;
byte arpeggioCounter = 0;
boolean arpeggioFlipMe = false;

byte defaultLevel = 10;

//Fast pin switching macros
#define CLR(x,y) (x&=(~(1<<y)))
#define SET(x,y) (x|=(1<<y))

#define __BCPORT__ PORTB
#define __BC1__ 2
#define __BDIR__ 3

#define __LEDPORT__ PORTB
#define __LED__ 5

#define __RGBLEDPORT__ PORTC
#define __RGBLEDDDR__ DDRC
#define __RLED__ 0
#define __GLED__ 1
#define __BLED__ 2

const int ledPin = 13;

const int tp[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4050,
                   3822, 3608, 3405, 3214, 3034, 2863, 2703, 2551, 2408, 2273, 2145, 4050, 3822,
                   3608, 3405, 3214, 3034, 2863, 2703, 2551, 2408, 2273, 2145, 2025, 1911, 1804, 1703,
                   1607, 1517, 1432, 1351, 1276, 1204, 1136, 1073, 1012, 956, 902, 851, 804, 758,
                   716, 676, 638, 602, 568, 536, 506, 478, 451, 426, 402, 379, 358, 338, 319, 301,
                   284, 268, 253, 239, 225, 213, 201, 190, 179, 169, 159, 150, 142, 134, 127, 119,
                   113, 106, 100, 95, 89, 84, 80, 75, 71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 40,
                   38, 36, 34, 32, 30, 28, 27, 25, 24, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13,
                   12, 11, 11, 10, 19, 18, 17, 16, 15, 14, 13, 13,
                   12, 11, 11, 10 };

// Samples C3-E3                   
                   
const int envTp[] = {3822, 3608, 3405, 3214, 3034, 2863, 2703, 2551, 2408, 2273, 2145, 2025, 1911, 1804, 1703, 1607, 1517, 1432, 1351, 1276, 1204, 1136, 1073, 1012, 956, 902, 851, 804, 758, 716, 676, 638, 602, 568, 536, 506, 478, 451, 426, 402, 379, 358, 338, 319, 301, 284, 268, 253, 239, 225, 213, 201, 190, 179, 169, 159, 150, 142, 134, 127, 119, 113, 106, 100, 95, 89, 84, 80, 75, 71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 40, 38, 36, 34, 32, 30, 28, 27, 25, 24, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2};

PROGMEM const char s0[] = {13, 14, 14, 13, 14, 15, 12, 14, 10, 14, 12, 14, 14, 13, 14, 12, 14, 13, 14, 12, 13, 12, 13, 11, 13, 12, 13, 12, 14, 13, 14, 14, 14, 15, 14, 15, 15, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 13, 12, 12, 11, 9, 7, 0, 0, 0, 0, 0, 5, 9, 11, 12, 12, 12, 13, 13, 14, 14, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 12, 12, 11, 12, 10, 12, 11, 10, 12, 10, 12, 9, 11, 9, 8, 6, 8, 0, 5, 5, 6, 0, 4, 4, 10, 10, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 12, 12, 11, 11, 10, 9, 9, 8, 7, 7, 8, 7, 8, 7, 11, 0, 11, 8, 10, 10, 10, 11, 9, 12, 9, 12, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 13, 12, 13, 12, 12, 13, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 12, 13, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 11, 11, 11, 11, 9, 9, 9, 8, 8, 5, 7, 5, 4, 4, 3, 6, 1, 4, 0, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 14, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 14, 14, 13, 13, 14, 13, 14, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 12, 11, 10};
const int s0Length = 931;
PROGMEM const char s1[] = {13, 14, 14, 14, 14, 14, 14, 13, 14, 14, 14, 13, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 13, 14, 13, 14, 14, 14, 14, 14, 13, 14, 14, 13, 13, 14, 14, 15, 14, 15, 15, 15, 15, 15, 14, 14, 13, 12, 11, 9, 0, 0, 0, 0, 0, 0, 0, 5, 0, 13, 12, 14, 0, 15, 14, 9, 15, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 13, 12, 12, 10, 9, 7, 0, 0, 0, 0, 0, 0, 4, 6, 8, 0, 0, 0, 0, 0, 0, 2, 9, 11, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 13, 11, 11, 6, 0, 0, 0, 0, 0, 7, 8, 0, 0, 0, 10, 12, 11, 13, 13, 13, 13, 12, 10, 11, 10, 12, 13, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 15, 14, 15, 13, 12, 14, 13, 13, 14, 14, 13, 13, 12, 9, 12, 12, 11, 11, 8, 8, 7, 0, 0, 4, 9, 10, 11, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 13, 14, 13, 13, 14, 13, 13, 12, 12, 11, 9, 8, 6, 0, 0, 0, 0, 0, 0, 4, 9, 11, 13, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 12, 11, 11, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 9, 11, 11, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 12, 13, 13, 12, 13, 12, 12, 12, 12, 11, 9, 9, 12, 11, 12, 8, 6, 11, 4, 10, 11, 10, 11, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 13, 14, 13, 13, 14, 13, 13, 14, 13, 14, 13, 13, 14, 14, 14, 13, 12, 12, 12, 12, 12, 11, 11, 10, 11, 10, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 14, 15, 15, 15, 15, 15, 15, 15, 14, 15, 14, 14, 14, 14, 14, 14, 13, 14, 14, 13, 14, 13, 12, 13, 12, 12, 13, 13, 13, 10, 11, 10, 12, 10, 10, 12, 12, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 14, 14, 14, 15, 14, 14, 14, 14, 13, 13, 13, 14, 13, 13, 14, 13, 13, 12, 13, 13, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 14, 15, 14, 14, 14, 13, 13, 12, 12, 12, 13, 12, 12, 13, 13, 13, 13, 14, 13, 13, 13, 13, 12, 12, 12, 13, 13, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 12, 13, 12, 12, 11, 12, 11, 12, 12, 11, 12, 11, 12, 12, 12, 12, 13, 12, 13, 13, 13, 13, 14, 14, 15, 15, 15, 14, 14, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 13, 13, 12, 13, 12, 12, 12, 13, 13, 12, 12, 13, 12, 12, 12, 12, 11, 11, 10, 11, 11, 11, 12, 13, 13, 14, 14, 14, 14, 15, 14, 15, 15, 14, 14, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 13, 12, 11, 12, 12, 12, 12, 11, 12, 11, 12, 13, 12, 13, 14, 13, 13, 14, 14, 14, 14, 14, 15, 14, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 9, 11, 11, 10, 12, 12, 12, 12, 12, 12, 13, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 14, 15, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 14, 15, 14, 14, 14, 13, 14, 14, 14, 14, 14, 13, 14, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 13, 13, 13, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 14, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 13, 14, 13, 13, 13, 13, 13, 13, 14, 14, 13, 14, 14, 14, 13, 14, 14, 14, 14, 14, 13, 13, 14, 13, 13, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 13, 13, 14, 13, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 12, 12, 13, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 14, 15, 15, 15, 14, 14, 14, 14, 13, 14, 14, 13, 13, 13, 13, 12, 13, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 14, 14, 14, 14, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 13, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 13, 14, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 14, 13, 13, 13, 12, 13, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 13, 13, 14, 13, 13, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 14, 14, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 13, 14, 13, 14, 14, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 14, 13, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 13, 13, 14, 13};
const int s1Length = 1780;
PROGMEM const char s2[] = {15, 13, 12, 13, 13, 14, 13, 15, 14, 13, 14, 13, 13, 14, 13, 14, 14, 13, 14, 12, 14, 14, 13, 13, 14, 13, 13, 13, 13, 14, 13, 14, 13, 13, 13, 14, 13, 13, 13, 13, 13, 14, 14, 13, 13, 14, 13, 13, 13, 13, 15, 13, 14, 13, 14, 13, 14, 12, 14, 13, 14, 13, 13, 14, 13, 13, 13, 13, 13, 13, 13, 14, 14, 15, 12, 15, 13, 14, 15, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 13, 13, 13, 14, 13, 14, 13, 14, 13, 13, 13, 15, 14, 13, 14, 14, 14, 13, 14, 13, 14, 13, 13, 13, 14, 14, 13, 13, 13, 14, 13, 13, 13, 14, 13, 13, 13, 14, 14, 13, 14, 13, 14, 13, 14, 14, 14, 13, 14, 13, 14, 13, 14, 13, 14, 13, 13, 14, 13, 14, 13, 13, 13, 14, 13, 14, 13, 14, 13, 14, 13, 13, 13, 13, 13, 14, 14, 13, 14, 13, 13, 14, 13, 13, 14, 13, 14, 14, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13, 13, 13, 14, 13, 13, 13, 14, 14, 14, 13, 13, 13, 14, 13, 14, 13, 13, 13, 13, 13, 14, 14, 13, 13, 13, 13, 13, 14, 13, 13, 14, 13, 13, 13, 13, 13, 14, 13, 13, 14, 13, 13, 14, 14, 13, 14, 13, 13, 13, 13, 14, 13, 13, 13, 14, 13, 13, 13, 14, 14, 14, 13, 13, 13, 14, 14, 13, 13, 14, 13, 13, 13, 13, 14, 13, 14, 13, 14, 13, 14, 14, 14, 13, 13, 13, 14, 13, 14, 14, 13, 14, 13, 14, 13, 13, 13, 14, 14, 13, 13, 13, 14, 13, 13, 14, 13, 14, 13, 13, 14, 13, 13, 13, 14, 13, 13, 13, 13, 14, 14, 13, 13, 13, 13, 14, 13, 13, 14, 13, 14, 13, 13, 14, 13, 14, 14, 13, 13, 14, 14, 13, 13, 14, 13, 14, 13, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 13, 13, 13, 13, 13, 13, 14, 13, 13, 14, 14, 13, 14, 13, 14, 13, 13, 13, 14, 13, 13, 13, 13, 14, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13, 13, 13, 14, 13, 13, 13, 14, 13, 14, 13, 14, 14, 13, 14, 13, 14, 13, 14, 13, 14, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13, 13, 14, 13, 13, 14, 13, 13, 14, 14, 13, 14, 13, 13, 14, 13, 14, 14, 13, 14, 13, 13, 13, 13, 13, 13, 14, 13, 14, 13, 13, 13, 13, 13, 14, 13, 13, 14, 13, 13};
const int s2Length = 463;
PROGMEM const char s3[] = {7, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 11, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 15, 14, 14, 14, 13, 13, 12, 12, 11, 11, 10, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 12, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 11, 11, 12, 12, 12, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11, 12, 12, 12, 13, 13, 13, 13, 14, 13, 13, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 6, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 9, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 13, 13, 13, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 11, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 6, 5, 5, 5, 4, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 12, 12, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 12, 12, 11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 13, 13, 12, 12, 11, 10, 9, 9, 8, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11, 11, 10, 9, 9, 8, 7, 7, 7, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 10, 11, 11, 11, 12, 12, 12, 13, 13, 12, 12, 12, 12, 12, 11, 10, 10, 9, 9, 8, 8, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 11, 10, 10, 9, 8, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 8, 8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5, 5, 6, 7, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
const int s3Length = 2982;
PROGMEM const char s4[] = {0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
const int s4Length = 741;
//const char* samplePointers[] = {s0, s1, s2, s3, s4};
//int sampleLength[] = {931,1780,463,8011,2869};
 
//Timer
const char* sampleOffset;
int sampleCounter = 0;
int sampleLength = 0;
int timerTicks = 0;

ISR(TIMER1_COMPA_vect)
{
  if (sampleCounter < sampleLength) //send current sample
  {
    send_data(0x0A, pgm_read_byte_near(sampleOffset + sampleCounter++));
    if ((sampleLength - sampleCounter) == 1) CLR(__RGBLEDPORT__,__BLED__);
  }
  
  timerTicks++;
  if (timerTicks == 220 && false) //arpeggio on chan B
  {
    timerTicks = 0;
    
    if (noteB > 0)
    {
        periodB = tp[noteB + arpeggio[arpeggioCounter]];
        byte LSB = ( periodB & 0x00FF);
        byte MSB = ((periodB >> 8) & 0x000F);
        send_data(0x02, LSB);
        send_data(0x03, MSB);
        
        arpeggioCounter++;
        if (arpeggioCounter == arpeggioLength) arpeggioCounter = 0;
    }
  }
}
int buttonPress;
int last_buttonPress;
// Stuff to blank the screen so it does not burn out.
unsigned long startMillis;  //some global variables available anywhere in the program
unsigned long currentMillis;
const unsigned long period = 120000;  //2 minutes - the value is a number of milliseconds before screen blanks
// Stuff to clear the sample play notication.
unsigned long startMillisS;  //some global variables available anywhere in the program
unsigned long currentMillisS;
const unsigned long periodS = 250;  //1 second - the value is a number of milliseconds before sample notification blanks
//////////////////////////////////////////////////////////
// I want to add another timer to listen for button presses or knob movement
//////////////////////////////////////////////////////////

void setup(){
  startMillis = millis();  //initial start time for screen blank
  startMillisS = millis();  //initial start time for sample blank
  u8x8.begin();
  u8x8.setPowerSave(0);
   u8x8.setFont(u8x8_font_chroma48medium8_r);
  u8x8.drawString(0,0,"v2.1a Oct 22"); 
  u8x8.setFont(u8x8_font_px437wyse700a_2x2_r);
   //u8x8.setFont(u8x8_font_chroma48medium8_r);
   u8x8.drawString(1,2,"YM2149F");
   //u8x8.drawString(4,4,"MIDI");
   u8x8.drawString(3,6,"Synth");
  //init pins
  pinMode(ad0, OUTPUT);
  pinMode(ad1, OUTPUT);
  pinMode(ad2, OUTPUT);
  pinMode(ad3, OUTPUT);
  pinMode(ad4, OUTPUT);
  pinMode(ad5, OUTPUT);
  pinMode(ad6, OUTPUT);
  pinMode(ad7, OUTPUT);
  pinMode(pinBC1, OUTPUT);
  pinMode(pinBDIR, OUTPUT);
  pinMode(pinYMReset, OUTPUT);
  pinMode(ledPin, OUTPUT);
   pinMode(buttonPin, INPUT);
//digitalWrite(buttonPin, HIGH );
  
 // __RGBLEDDDR__ |= ( 1 << __RLED__ | 1 << __GLED__ | 1 << __BLED__); //led pins as output
  
  resetYM();
  
  AmaxVolume = defaultLevel;
  BmaxVolume = defaultLevel;
  CmaxVolume = defaultLevel;
  
  //serial init
  Serial.begin(31250);
  
  //timer1 : sample player
  cli();
  TCCR1A = 0; //timer reset
  TCCR1B = 0; //timer reset
  OCR1A = 1450; //period for 11025 kHz at 16Mhz
  TCCR1B |= (1 << WGM12); //CTC mode
  TCCR1B |= (1 << CS10); // timer ticks = clock ticks
  TIMSK1 |= (1 << OCIE1A); // enable compare
  sei();
  
  //say hello
  //This is the bleep played on power on.
      ////note/velo/channel
playNote(78, 127, 1);  // F#5
delay(30);             // Shorter delay for chiptune feel
playNote(76, 127, 1);  // E5
delay(30);
playNote(74, 127, 1);  // D5
delay(30);
playNote(72, 127, 1);  // C5
delay(30);
playNote(70, 127, 1);  // B4
delay(30);
playNote(69, 127, 1);  // A4
delay(30);
playNote(67, 127, 1);  // G4
delay(30);
playNote(65, 127, 1);  // F4
delay(30);
playNote(64, 127, 1);  // E4
delay(30);
playNote(62, 127, 1);  // D4
delay(30);
stopNote(62, 1);       // Stop D4       // Stop D4
// playDigidrum(59, 127);// Sample
  delay(4000);
   u8x8.clearDisplay();

  // u8x8.clearLine(7);
  
    //  u8x8.setCursor(0,7);
   //  u8x8.print(analogRead(A1));
}//END OF SETUP

// Main Loop
void loop() {
     //u8x8.setCursor(0,7);
     //u8x8.print(analogRead(A1));
     currentMillis = millis();  //get the current "time" (actually the number of milliseconds since the program started)
  if (currentMillis - startMillis >= period)  //test whether the period has elapsed
  {
     u8x8.clearDisplay();
     //if so, change the state of the LED.  Uses a neat trick to change the state
    startMillis = currentMillis;  //IMPORTANT reset timer for screen.
  }

   currentMillisS = millis();  //get the current "time" (actually the number of milliseconds since the program started)
  if (currentMillisS - startMillisS >= periodS)  //test whether the period has elapsed
  {
      u8x8.setCursor(13,0);
     u8x8.print("   ");
      u8x8.setCursor(13,1);
     u8x8.print("   ");
      u8x8.setCursor(13,2);
     u8x8.print("   ");
      u8x8.setCursor(13,3);
     u8x8.print("   ");
      u8x8.setCursor(13,4);
     u8x8.print("   ");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
  byte command = getSerialByte();
  byte commandMSB  = command & 0xF0;
  byte midiChannel = command & 0x0F;
  
  if (commandMSB == 0x80) //Note off
  {
    byte note = getSerialByte();
    getSerialByte(); //discard 3rd byte
    stopNote(note, midiChannel);
  }
  else if (commandMSB == 0x90) //Note on
  {
    byte note = getSerialByte();
    byte velo = getSerialByte();
    // Ifi ts Midi channel 10 we trigger samples using the playDigidrum(); function. 
    if (velo != 0 && midiChannel == 0x09)
      playDigidrum(note, velo);
    else if (velo != 0)
      playNote(note, velo, midiChannel);
    else if (velo == 0)
      stopNote(note, midiChannel);
  }
  else if (commandMSB == 0xA0) // Key pressure
  {
    getSerialByte();
    getSerialByte();
  }
  else if (commandMSB == 0xB0) // Control change
  {
    byte controller = getSerialByte();
    byte value = getSerialByte();
    
    if (controller == 0x01) setDetune(value);
    if (controller == 0x07) setChannelVolume(value, midiChannel);
  }
  else if (commandMSB == 0xC0) // Program change
  {
    byte program = getSerialByte();
  }
  else if (commandMSB == 0xD0) // Channel pressure
  {
    byte pressure = getSerialByte();
  }
  else if (commandMSB == 0xE0) // Pitch bend
  {
    byte pitchBendLSB = getSerialByte();
    byte pitchBendMSB = getSerialByte();
  }
}

void setDetune(byte value)
{
  detuneValue = (value >> 3) & 0x0F; //downscaling to 4 bits
}

void setChannelVolume(byte value, byte chan)
{
  value = (value >> 3) & 0x0F; //downscaling to 4 bits
  
  if (chan == 0)
  {
    AmaxVolume = value;
    send_data(0x08, value);
  }  
  else if (chan == 1)
  {
    BmaxVolume = value;
    send_data(0x09, value);
  }
  else if (chan == 2)
  {
    CmaxVolume = value;
    send_data(0x0A, value);
  } 
}

// MIDI Note and Volume Playback
void playNote(byte note, byte velo, byte chan) {
    // Check if the note value is within the valid range
    if (note < 24) return; // Invalid note, exit function
    SET(__LEDPORT__,__LED__);
    // Ensure velocity is within the valid range
    if (velo < 0) {
        velo = 0; // Ensure velocity does not go below 0
    } else if (velo > 127) {
        velo = 127; // Ensure velocity does not exceed 127
    }

    // Remap the velocity to the desired range
    if (velo <= 1) {
        velo = 64; // Map 0-1 to 64
    } else {
        velo = 64 + (velo / 2); // Map 2-127 to 65-127
    }
    byte volume = map(velo, 0, 127, 0, 15); // Scale velocity to volume range (0-15)

    // Handle MIDI Channel 1
    if (chan == 0) {
        noteA = note; // Set the note for Channel A
        periodA = tp[note]; // Retrieve the period for the note
        byte LSB = (periodA & 0x00FF); // Get the LSB of the period
        byte MSB = ((periodA & 0x0F00) >> 8); // Get the MSB of the period
        cli(); // Disable interrupts
        send_data(0x00, LSB); // Send LSB to register 0x00
        send_data(0x01, MSB); // Send MSB to register 0x01
        send_data(0x08, volume); // comment to disable volume based on velocity
        sei(); // Enable interrupts
        // Update display for Channel A
        u8x8.setFont(u8x8_font_chroma48medium8_r);
        u8x8.drawString(0, 0, "[1]A");
        u8x8.setCursor(7, 0);
        u8x8.print(noteA);
        u8x8.setCursor(10, 0);
        u8x8.print(volume);
        startMillis = currentMillis; // Reset screen timeout
    }
    // Handle MIDI Channel 2
    else if (chan == 1) {
        noteB = note; // Set the note for Channel B
        periodB = tp[note]; // Retrieve the period for the note
        byte LSB = (periodB & 0x00FF); // Get the LSB of the period
        byte MSB = ((periodB >> 8) & 0x000F); // Get the MSB of the period
        cli(); // Disable interrupts
        arpeggioCounter = 0; // Reset arpeggio counter
        send_data(0x02, LSB); // Send LSB to register 0x02
        send_data(0x03, MSB); // Send MSB to register 0x03
        send_data(0x09, volume); // comment to disable volume based on velocity
        sei(); // Enable interrupts
        // Update display for Channel B
        u8x8.setFont(u8x8_font_chroma48medium8_r);
        u8x8.drawString(0, 1, "[2] B");
        u8x8.setCursor(7, 1);
        u8x8.print(noteB);
        u8x8.setCursor(10, 1);
        u8x8.print(volume);
        startMillis = currentMillis; // Reset screen timeout
    }
    // Handle MIDI Channel 3
    else if (chan == 2) {
        noteC = note; // Set the note for Channel C
        periodC = tp[note]; // Retrieve the period for the note
        byte LSB = (periodC & 0x00FF); // Get the LSB of the period
        byte MSB = ((periodC >> 8) & 0x000F); // Get the MSB of the period
        cli(); // Disable interrupts
        send_data(0x04, LSB); // Send LSB to register 0x04
        send_data(0x05, MSB); // Send MSB to register 0x05
        send_data(0x0A, volume); // comment to disable volume based on velocity
        sei(); // Enable interrupts
        // Update display for Channel C
        u8x8.setFont(u8x8_font_chroma48medium8_r);
        u8x8.drawString(0, 2, "[3] C");
        u8x8.setCursor(7, 2);
        u8x8.print(noteC);
        u8x8.setCursor(10, 2);
        u8x8.print(volume);
        startMillis = currentMillis; // Reset screen timeout
    }
    // Handle MIDI Channel 4
    else if (chan == 3) {
        if (mm3 == 0) {
            noteA = note; // Set the note for Channel A
            noteB = note; // Set the note for Channel B
            periodA = tp[note]; // Retrieve the period for note A
            periodB = tp[note] + detuneValue; // Apply detune for note B
            
            byte ALSB = (periodA & 0x00FF); // Get the LSB of period A
            byte AMSB = ((periodA >> 8) & 0x000F); // Get the MSB of period A
            byte BLSB = (periodB & 0x00FF); // Get the LSB of period B
            byte BMSB = ((periodB >> 8) & 0x000F); // Get the MSB of period B
            cli(); // Disable interrupts
            send_data(0x00, ALSB); // Send LSB of period A to register 0x00
            send_data(0x01, AMSB); // Send MSB of period A to register 0x01
            send_data(0x02, BLSB); // Send LSB of period B to register 0x02
            send_data(0x03, BMSB); // Send MSB of period B to register 0x03
            send_data(0x08, volume); // Set volume based on velocity for Channel A
            send_data(0x09, volume); // Set volume based on velocity for Channel B
            sei(); // Enable interrupts
            // Update display for Channel AB
            u8x8.setFont(u8x8_font_chroma48medium8_r);
            u8x8.clearLine(3);
            u8x8.drawString(0, 3, "[4]AB");
            u8x8.setCursor(7, 3);
            u8x8.print(noteA);
            u8x8.setCursor(10, 3);
            u8x8.print(volume);
            startMillis = currentMillis; // Reset screen timeout
        }
    }
    // Handle MIDI Channel 5
else if (chan == 4) { 
    noteA = note; // Set the note for Channel A
    noteB = note; // Set the note for Channel B
    noteC = note; // Set the note for Channel C

    periodA = tp[note - 12]; // Retrieve the period for note A
    periodB = tp[note] + detuneValue; // Apply detune for note B
    periodC = tp[note] - detuneValue; // Apply detune for note C

    byte ALSB = (periodA & 0x00FF); // Get the LSB of period A
    byte AMSB = ((periodA >> 8) & 0x000F); // Get the MSB of period A
    byte BLSB = (periodB & 0x00FF); // Get the LSB of period B
    byte BMSB = ((periodB >> 8) & 0x000F); // Get the MSB of period B
    byte CLSB = (periodC & 0x00FF); // Get the LSB of period C
    byte CMSB = ((periodC >> 8) & 0x000F); // Get the MSB of period C

    cli(); // Disable interrupts
    send_data(0x00, ALSB); // Send LSB of period A to register 0x00
    send_data(0x01, AMSB); // Send MSB of period A to register 0x01
    send_data(0x02, BLSB); // Send LSB of period B to register 0x02
    send_data(0x03, BMSB); // Send MSB of period B to register 0x03
    send_data(0x04, CLSB); // Send LSB of period C to register 0x04
    send_data(0x05, CMSB); // Send MSB of period C to register 0x05
    sei(); // Enable interrupts

    // Update display for Channel ABC
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(4);
    u8x8.drawString(0, 4, "[5]ABC");
    u8x8.setCursor(7, 4);
    u8x8.print(noteA);
    u8x8.setCursor(10, 4);
    u8x8.print(volume);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 5) { // MIDI Channel 6
    noteA = note;
    periodA = envTp[note];

    byte LSB = (periodA & 0x00FF); // Get LSB of period A
    byte MSB = ((periodA >> 8) & 0x000F); // Get MSB of period A

    cli(); // Disable interrupts
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, LSB); // Send LSB to register 0x0B
    send_data(0x0C, MSB); // Send MSB to register 0x0C
    send_data(0x0D, 0b00001000); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel A
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(5);
    u8x8.drawString(0, 5, "[6]A");
    u8x8.setCursor(7, 5);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 6) { // MIDI Channel 7
    noteA = note;
    periodA = envTp[note];

    byte LSB = (periodA & 0x00FF); // Get LSB of period A
    byte MSB = ((periodA >> 8) & 0x000F); // Get MSB of period A

    cli(); // Disable interrupts
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, LSB); // Send LSB to register 0x0B
    send_data(0x0C, MSB); // Send MSB to register 0x0C
    send_data(0x0D, 0b00001000); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel A
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(6);
    u8x8.drawString(0, 6, "[7]A");
    u8x8.setCursor(7, 6);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 7) { // MIDI Channel 8
    noteA = note;
    noteB = note;
    periodA = envTp[note];
    periodB = (tp[note - 12] + detuneValue) << 1; // Apply detune and shift

    byte LSB = (periodA & 0x00FF); // Get LSB of period A
    byte MSB = ((periodA >> 8) & 0x000F); // Get MSB of period A
    byte BLSB = (periodB & 0x00FF); // Get LSB of period B
    byte BMSB = ((periodB >> 8) & 0x000F); // Get MSB of period B

    cli(); // Disable interrupts
    send_data(0x02, BLSB); // Send LSB of period B
    send_data(0x03, BMSB); // Send MSB of period B
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, LSB); // Send LSB of period A
    send_data(0x0C, MSB); // Send MSB of period A
    send_data(0x0D, 0b00001100); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel AB
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(7);
    u8x8.drawString(0, 7, "[8]AB");
    u8x8.setCursor(7, 7);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 8) { // MIDI Channel 9
    noteA = note;
    noteB = note;
    periodA = envTp[note];
    periodB = tp[note - 24]; // Retrieve period for note B

    byte LSB = (periodA & 0x00FF); // Get LSB of period A
    byte MSB = ((periodA >> 8) & 0x000F); // Get MSB of period A
    byte BLSB = (periodB & 0x00FF); // Get LSB of period B
    byte BMSB = ((periodB >> 8) & 0x000F); // Get MSB of period B

    cli(); // Disable interrupts
    send_data(0x02, BLSB); // Send LSB of period B
    send_data(0x03, BMSB); // Send MSB of period B
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, LSB); // Send LSB of period A
    send_data(0x0C, MSB); // Send MSB of period A
    send_data(0x0D, 0b00001110); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel AB
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(7);
    u8x8.drawString(0, 7, "[8]AB");
    u8x8.setCursor(7, 7);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 10) { // MIDI Channel 11 Clicks and Pops
    noteA = note;
    periodA = tp[note - 12];

    byte LSB = (periodA & 0x00FF); // Get LSB of period A
    byte MSB = ((periodA & 0x0F00) >> 8); // Get MSB of period A

    cli(); // Disable interrupts
    send_data(0x00, LSB); // Send LSB to register 0x00
    send_data(0x01, MSB); // Send MSB to register 0x01
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0D, 0b00011111); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Clicks and Pops
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(9);
    u8x8.drawString(0, 9, "[10]CP");
    u8x8.setCursor(7, 9);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 11) // MIDI Channel 12
{
    noteA = note; // Set note for Channel A
    noteB = note; // Set note for Channel B
    noteC = note; // Set note for Channel C
    
    periodA = tp[note - 12]; // Get period for note A
    periodB = tp[note + 12]; // Get period for note B
    periodC = tp[note];      // Get period for note C
    
    byte ALSB = (periodA & 0x00FF); // Get LSB of period A
    byte AMSB = ((periodA >> 8) & 0x000F); // Get MSB of period A
    byte BLSB = (periodB & 0x00FF); // Get LSB of period B
    byte BMSB = ((periodB >> 8) & 0x000F); // Get MSB of period B
    byte CLSB = (periodC & 0x00FF); // Get LSB of period C
    byte CMSB = ((periodC >> 8) & 0x000F); // Get MSB of period C

    cli(); // Disable interrupts
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, BLSB); // Send LSB of period B
    send_data(0x0C, BMSB); // Send MSB of period B
    send_data(0x0D, 0b00001100); // Set attack and sustain
    send_data(0x00, ALSB); // Send LSB of period A
    send_data(0x01, AMSB); // Send MSB of period A
    send_data(0x04, CLSB); // Send LSB of period C
    send_data(0x05, CMSB); // Send MSB of period C
    sei(); // Enable interrupts

    // Update display for Channel ABC
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(4);
    u8x8.drawString(0, 4, "[5]ABC");
    u8x8.setCursor(7, 4);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 12) // MIDI Channel 13
{
    noteA = note; // Set note for Channel A
    noteB = note; // Set note for Channel B
    noteC = note; // Set note for Channel C
    
    periodA = tp[note - 12]; // Get period for note A    
    periodB = tp[note - 12]; // Get period for note B
    periodC = tp[note];      // Get period for note C
    
    byte ALSB = (periodA & 0x00FF); // Get LSB of period A
    byte AMSB = ((periodA >> 8) & 0x000F); // Get MSB of period A
    byte BLSB = (periodB & 0x00FF); // Get LSB of period B
    byte BMSB = ((periodB >> 8) & 0x000F); // Get MSB of period B
    byte CLSB = (periodC & 0x00FF); // Get LSB of period C
    byte CMSB = ((periodC >> 8) & 0x000F); // Get MSB of period C

    cli(); // Disable interrupts
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x0B, BLSB); // Send LSB of period B
    send_data(0x0C, BMSB); // Send MSB of period B
    send_data(0x00, ALSB); // Send LSB of period A
    send_data(0x01, AMSB); // Send MSB of period A
    send_data(0x04, CLSB); // Send LSB of period C
    send_data(0x05, CMSB); // Send MSB of period C
    send_data(0x0D, 0b00101100); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel ABC
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(4);
    u8x8.drawString(0, 4, "[5]ABC");
    u8x8.setCursor(7, 4);
    u8x8.print(noteA);
    startMillis = currentMillis; // Reset screen timeout
}
else if (chan == 13) // MIDI Channel 14
{
    noteC = note; // Set note for Channel C
    periodC = envTp[note]; // Get period for note C
    
    byte LSB = (periodC & 0x00FF); // Get LSB of period C
    byte MSB = ((periodC >> 8) & 0x000F); // Get MSB of period C

    cli(); // Disable interrupts
    send_data(0x08, 0x10); // Enable envelope mode
    send_data(0x00, LSB); // Send LSB of period C
    send_data(0x01, MSB); // Send MSB of period C
    send_data(0x0D, 0b00111000); // Set attack and sustain
    sei(); // Enable interrupts

    // Update display for Channel A
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.clearLine(5);
    u8x8.drawString(0, 5, "[6]A");
    u8x8.setCursor(7, 5);
    u8x8.print(noteC);
    startMillis = currentMillis; // Reset screen timeout
}
}

/**
 * @brief Stops a MIDI note for a specified channel.
 *
 * This function resets the note and period for the specified MIDI channel
 * and sends commands to stop the sound associated with that note.
 *
 * @param note The MIDI note number to stop.
 * @param chan The MIDI channel number corresponding to the note.
 */
void stopNote(byte note, byte chan)
{
    // Check if the channel is 0 (MIDI Channel 1)
    if (chan == 0 && note == noteA) {
        // Stop note A
        noteA = periodA = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x00, 0); // Stop Channel 1 frequency LSB
        send_data(0x01, 0); // Stop Channel 1 frequency MSB  
        sei(); // Enable interrupts
    }
    // Check if the channel is 1 (MIDI Channel 2)
    else if (chan == 1 && note == noteB) {
        // Stop note B
        noteB = periodB = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x02, 0); // Stop Channel 2 frequency LSB
        send_data(0x03, 0); // Stop Channel 2 frequency MSB
        sei(); // Enable interrupts
    }
    // Check if the channel is 2 (MIDI Channel 3)
    else if (chan == 2 && note == noteC) {
        // Stop note C
        noteC = periodC = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x04, 0); // Stop Channel 3 frequency LSB
        send_data(0x05, 0); // Stop Channel 3 frequency MSB
        sei(); // Enable interrupts
    }
    // Check if the channel is 3 (MIDI Channel 4)
    else if (chan == 3 && note == noteA) {
        // Stop note A for channel 4
        noteA = periodA = 0; // Reset note and period
        noteB = periodB = 0; // Stop note B as well
        cli(); // Disable interrupts
        send_data(0x00, 0); // Stop Channel 1 frequency LSB
        send_data(0x01, 0); // Stop Channel 1 frequency MSB
        send_data(0x02, 0); // Stop Channel 2 frequency LSB
        send_data(0x03, 0); // Stop Channel 2 frequency MSB
        sei(); // Enable interrupts
    }
    // Check if the channel is 4 (MIDI Channel 5)
    else if (chan == 4 && note == noteA) {
        // Stop note A for channel 5
        noteA = periodA = 0; // Reset note and period
        noteB = periodB = 0; // Stop note B
        noteC = periodC = 0; // Stop note C
        cli(); // Disable interrupts
        send_data(0x00, 0); // Stop Channel 1 frequency LSB
        send_data(0x01, 0); // Stop Channel 1 frequency MSB
        send_data(0x02, 0); // Stop Channel 2 frequency LSB
        send_data(0x03, 0); // Stop Channel 2 frequency MSB
        send_data(0x04, 0); // Stop Channel 3 frequency LSB
        send_data(0x05, 0); // Stop Channel 3 frequency MSB
        sei(); // Enable interrupts
    }
    // Check if the channel is 5 (MIDI Channel 6)
    else if (chan == 5 && note == noteA) {
        // Stop note A for channel 6
        noteA = periodA = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x0D, 0); // Stop envelope effect
        send_data(0x08, AmaxVolume); // Set maximum volume
        sei(); // Enable interrupts
    }
    // Check if the channel is 6 (MIDI Channel 7)
    else if (chan == 6 && note == noteA) {
        // Stop note A for channel 7
        noteA = periodA = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x0D, 0); // Stop envelope effect
        send_data(0x08, AmaxVolume); // Set maximum volume
        sei(); // Enable interrupts
    }
    // Check if the channel is 7 (MIDI Channel 8)
    else if (chan == 7 && note == noteA) {
        // Stop note A for channel 8
        noteA = periodA = 0; // Reset note and period
        noteB = periodB = 0; // Stop note B
        cli(); // Disable interrupts
        send_data(0x02, 0); // Stop Channel 2 frequency LSB
        send_data(0x03, 0); // Stop Channel 2 frequency MSB
        send_data(0x0D, 0); // Stop envelope effect
        send_data(0x08, AmaxVolume); // Set maximum volume
        sei(); // Enable interrupts
    }
    // Check if the channel is 8 (MIDI Channel 9)
    else if (chan == 8 && note == noteA) {
        // Stop note A for channel 9
        noteA = periodA = 0; // Reset note and period
        noteB = periodB = 0; // Stop note B
        cli(); // Disable interrupts
        send_data(0x02, 0); // Stop Channel 2 frequency LSB
        send_data(0x03, 0); // Stop Channel 2 frequency MSB
        send_data(0x0D, 0); // Stop envelope effect
        send_data(0x0B, 0); // Stop Channel 3 frequency LSB
        send_data(0x0C, 0); // Stop Channel 3 frequency MSB
        send_data(0x08, AmaxVolume); // Set maximum volume
        sei(); // Enable interrupts
    }
    // Check if the channel is 10 (MIDI Channel 11)
    else if (chan == 10 && note == noteA) {
        // Stop note A for channel 11
        noteA = periodA = 0; // Reset note and period
        cli(); // Disable interrupts
        send_data(0x00, 0); // Stop Channel 1 frequency LSB
        send_data(0x01, 0); // Stop Channel 1 frequency MSB  
        sei(); // Enable interrupts
    }
    // Check if the channel is 11 (MIDI Channel 12)
    else if (chan == 11 && note == noteA) {
        cli(); // Disable interrupts

        // Reset note periods
        noteA = periodA = 0;
        noteB = periodB = 0;
        noteC = periodC = 0;

        // Stop the envelope effect for all channels
        send_data(0x08, 0x00); // Turn envelope mode off

        // Send zero to all frequency registers to stop the sound
        send_data(0x00, 0); // Channel 1 frequency LSB
        send_data(0x01, 0); // Channel 1 frequency MSB
        send_data(0x02, 0); // Channel 2 frequency LSB
        send_data(0x03, 0); // Channel 2 frequency MSB
        send_data(0x04, 0); // Channel 3 frequency LSB
        send_data(0x05, 0); // Channel 3 frequency MSB
        send_data(0x0B, 0); // Stop envelope register
        send_data(0x0C, 0); // Stop envelope register
        sei(); // Enable interrupts
    }
    // Check if the channel is 12 (MIDI Channel 13)
    else if (chan == 12 && note == noteA) {
        cli(); // Disable interrupts

        // Reset note periods
        noteA = periodA = 0;
        noteB = periodB = 0;
        noteC = periodC = 0;

        // Stop the envelope effect for all channels
        send_data(0x08, 0x00); // Turn envelope mode off

        // Send zero to all frequency registers to stop the sound
        send_data(0x00, 0); // Channel 1 frequency LSB
        send_data(0x01, 0); // Channel 1 frequency MSB
        send_data(0x02, 0); // Channel 2 frequency LSB
        send_data(0x03, 0); // Channel 2 frequency MSB
        send_data(0x04, 0); // Channel 3 frequency LSB
        send_data(0x05, 0); // Channel 3 frequency MSB
        send_data(0x0B, 0); // Stop envelope register
        send_data(0x0C, 0); // Stop envelope register

        sei(); // Enable interrupts
    }
    // Check if the channel is 13 (MIDI Channel 14)
    else if (chan == 13 && note == noteC) {
        cli(); // Disable interrupts
        noteC = periodC = 0; // Reset note and period
        send_data(0x00, 0); // Stop Channel 1 frequency LSB
        send_data(0x01, 0); // Stop Channel 1 frequency MSB
        send_data(0x08, 0x00); // Turn envelope mode off
        sei(); // Enable interrupts
    }
}

void playDigidrum(byte index, byte velo)
{
  if (index == 64)
  {
    cli();
    
    sampleOffset = s0;
    sampleLength = s0Length;
    sampleCounter = 0;
    sei();
      u8x8.setCursor(13,0);
     u8x8.print("[1]");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
  else if (index == 63)
  {
    cli();
 
    sampleOffset = s1;
    sampleLength = s1Length;
    sampleCounter = 0;
    sei();
      u8x8.setCursor(13,1);
     u8x8.print("[2]");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
  else if (index == 62)
  {
    cli();

    sampleOffset = s2;
    sampleLength = s2Length;
    sampleCounter = 0;
    sei();
       u8x8.setCursor(13,2);
     u8x8.print("[3]");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
  else if (index == 61)
  {
    cli();
 
    sampleOffset = s3;
    sampleLength = s3Length;
    sampleCounter = 0;
    sei();
       u8x8.setCursor(13,3);
     u8x8.print("[4]");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
  else if (index == 60)
  {
    cli();
  
    sampleOffset = s4;
    sampleLength = s4Length;
    sampleCounter = 0;
    sei();
      u8x8.setCursor(13,4);
     u8x8.print("[5]");
     startMillisS = currentMillisS;  //IMPORTANT reset timer for screen.
  }
}

void resetYM()
{
    digitalWrite(pinYMReset, LOW);
    digitalWrite(pinYMReset, HIGH);
    delay(1);
    send_data(0x07, 0b00111000);
    for (byte i=0; i <= defaultLevel; i++)
    {
      send_data(0x08, i);
      send_data(0x09, i);
      send_data(0x0A, i);
      delay(1);
    }
}

void send_data(unsigned char address, unsigned char data)
{
  boolean value[8];
  
  //put address in a 8-bit array
  for (int i; i < 8; i++)
  {
    value[i] = ((0x01 & address) == 1);
    address = address >> 1;
  }
  //write address to pins
  outputToYM(value);
  //validate addess
  __BCPORT__ |=   (1 << __BDIR__) | (1 << __BC1__);
  delayMicroseconds(1);
  __BCPORT__ &= ~((1 << __BDIR__) | (1 << __BC1__));

  //put data in a 8-bit array
  for (int i; i < 8; i++)
  {
    value[i] = ((0x01 & data) == 1);
    data = data >> 1;
  }
  //write data to pins
  outputToYM(value);
  //validate data
  SET(__BCPORT__,__BDIR__);
  delayMicroseconds(1);
  CLR(__BCPORT__,__BDIR__);
  CLR(__LEDPORT__,__LED__);
}

void outputToYM(boolean value[])
{
  value[0] ? SET(PORTB, 0) : CLR(PORTB, 0);
  value[1] ? SET(PORTB, 1) : CLR(PORTB, 1);
  value[2] ? SET(PORTD, 2) : CLR(PORTD, 2);
  value[3] ? SET(PORTD, 3) : CLR(PORTD, 3);
  value[4] ? SET(PORTD, 4) : CLR(PORTD, 4);
  value[5] ? SET(PORTD, 5) : CLR(PORTD, 5);
  value[6] ? SET(PORTD, 6) : CLR(PORTD, 6);
  value[7] ? SET(PORTD, 7) : CLR(PORTD, 7);
}

byte getSerialByte()
{
  while(Serial.available() < 1) __asm__("nop\n\t");
  return Serial.read();
}
